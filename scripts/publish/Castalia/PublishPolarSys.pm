package Castalia::PublishPolarSys;

use strict;
use warnings;

use Data::Dumper;
use JSON qw( decode_json encode_json );

# Used for ceil() and floor()
use POSIX;

use Castalia::PublishStatic qw( build_page read_json);
use Castalia::PublishHTML qw( get_html_qm );

use Exporter qw( import );
 
our @EXPORT_OK = qw( 
    generate_doc_metrics
    generate_doc_questions
    generate_doc_attributes
    generate_all_projects 
);

my $debug = 0;

my %flat_metrics;
my %flat_questions;
my %flat_attributes;
my %flat_rules;
my %flat_refs;

#    my @colours = ("#ebebeb", "#ccffff", "#99d9ff", "#66b3ff", "#338cff", "#0066ff");
my @colours = ("#ebebeb", "#FFFF66", "#CCF24D", "#99E633", "#66D91A", "#33CC00");

my %project_errors;

my %metrics_ds;

sub new($$$) {
    my $class = shift;
    my $self = {
        # _f_metrics => shift,
        # _f_questions  => shift,
        # _f_attributes       => shift,
    };

    bless $self, $class;
    return $self;
}

sub generate_downloads($$$$) {
    my $project_id = shift;
    my $type = shift;
    my $dir_out_projects = shift;
    my $project_values = shift;

    # Write all values to single csvfile.
    my $out_json = $dir_out_projects . "/${project_id}_${type}.json";
    print "    - Writing " . $type . " to file [$out_json]..\n";    
    my $out_data = {
	'name' => ucfirst($type) . ' for project ' . $project_id,
	'version' => 'Generated by the dashboard',
	'children' => $project_values
    };
    open(my $fh, '>', $out_json) or die "Could not open file '$out_json' $!";
    print $fh encode_json($out_data);
    close $fh;

    # Write all values to single json file.
    my $out_csv = $dir_out_projects . "/${project_id}_${type}.csv";
    print "    - Writing " . $type . " to file [$out_csv]..\n";  
    $out_data = "Project," . join(',', sort keys %{$project_values}) . "\n";
#    $out_data = "$type,${project_id}\n";
    my @values;
    foreach my $line (sort keys %{$project_values}) {
	push(@values, $project_values->{$line});
#	$out_data .= "$line," . $project_values->{$line};
    }
    $out_data .= $project_id . "," . join(',', @values) . "\n";
    open($fh, '>', $out_csv) or die "Could not open file '$out_json' $!";
    print $fh $out_data;
    close $fh;
}


sub generate_progressbar($$$$) {
    my $name = shift;
    my $value = shift;
    my $conf = shift;
    my $project_id = shift || "";

    if ($value < 0 or $value > 5) {
	my $err = "ERR: Value $value should be between 1 and 5.";
	push( @{$project_errors{$project_id}}, $err);
        print "\n$err\n";
    }

    my $percent = 20 * $value;

    my $ret = '
                  <dt>' . $name . ' <span class="pull-right">( ' . $conf . 
		  ' metrics )</span></dt>
                  <dd>
                    <div class="progress">';
    $ret .= '
                      <div class="progress-bar" role="progressbar" aria-valuenow="'
         . $value . '" aria-valuemin="0" aria-valuemax="5"  style="background-color: ' . $colours[$value]
	 . ';width: ' . $percent . '%;">' . $value .  ' / 5</div>
                    </div>
                  </dd>';
    
    return $ret;
}


sub generate_doc_qm($$) {
    my $class = shift;
    my $qm_file = shift;

    print "    - Reading qm from [$qm_file].\n";
    my $raw_qm = &read_json($qm_file);
    &populate_qm($raw_qm->{"children"}, undef, undef, undef, undef);

    return encode_json($raw_qm);
}


# Recursive function to populate the quality model with information from 
# external files (metrics/questions/attributes definition). 
# Params:
#   $qm a ref to an array of children
#   $attrs a ref to hash of values for attributes
#   $questions a ref to hash of values for questions
#   $metrics a ref to hash of values for metrics
#   $inds a ref to hash of indicators for metrics
sub populate_qm($$$$$) {
    my $qm = shift;
    my $attrs = shift;
    my $questions = shift;
    my $metrics = shift;
    my $inds = shift;
    
    foreach my $child (@{$qm}) {
	my $mnemo = $child->{"mnemo"};
	
	if ($child->{"type"} =~ m!attribute!) {
	    $child->{"name"} = $flat_attributes{$mnemo}{"name"};
	    $child->{"ind"} = $attrs->{$mnemo};
	} elsif ($child->{"type"} =~ m!concept!) {
	    $child->{"name"} = $flat_questions{$mnemo}{"name"};
	    $child->{"ind"} = $questions->{$mnemo};
	} elsif ($child->{"type"} =~ m!metric!) {
	    $child->{"name"} = $flat_metrics{$mnemo}{"name"};
	    $child->{"value"} = $metrics->{$mnemo};
	    $child->{"ind"} = $inds->{$mnemo};
	} else { print "WARN: cannot recognize type " . $child->{"type"} . "\n"; }

	if ( exists($child->{"children"}) ) {
	    &populate_qm($child->{"children"}, $attrs, $questions, $metrics, $inds);
	}
    }
}

sub is_ordered_scale($) {
    my $scale = shift;

    # Check if the scale is normal or reverse
    my $scale_unsort = join(' ', @{$scale});
    my $scale_sort = join(' ', sort { $a <=> $b } @{$scale});
    my $scale_revsort = join(' ', sort { $b <=> $a } @{$scale});

    my $is_sorted;
    if ($scale_sort eq $scale_unsort) {
	$is_sorted = 1;
    } elsif ($scale_revsort eq $scale_unsort) {
	$is_sorted = 0;
    } else {
	my $err = "WARN: scale [" . $scale_unsort . 
	    "] is not right. Not using it.\n";
	push( @{$project_errors{'MAIN'}}, $err);
	if ($debug) {
	    print $err;
	}
    }

    return $is_sorted
}


# Computes indicators (range 1-5) from metrics (wide range).
# Params:
#   $value the value to be converted
#   $scale a ref to an array of 4 values describing the scale
sub compute_scale($$) {
    my $value = shift;
    my $scale = shift;

    my $is_sorted = &is_ordered_scale($scale);
    my $indicator;

    # If the value is not defined we want to return undef
    if ( defined($value) ) {
	if ( $is_sorted ) {
	    if ( $value < $scale->[0] ) { $indicator = 1 }
	    elsif ( $value < $scale->[1] ) { $indicator = 2 }
	    elsif ( $value < $scale->[2] ) { $indicator = 3 }
	    elsif ( $value < $scale->[3] ) { $indicator = 4 }
	    else { $indicator = 5 }
	} else {
	    if ( $value > $scale->[0] ) { $indicator = 1 }
	    elsif ( $value > $scale->[1] ) { $indicator = 2 }
	    elsif ( $value > $scale->[2] ) { $indicator = 3 }
	    elsif ( $value > $scale->[3] ) { $indicator = 4 }
	    else { $indicator = 5 }	    
	}
    }

    return $indicator;
}


sub aggregate_inds($$$$$) {
    my $raw_qm = shift;
    my $values = shift;
    my $inds_ref = shift;
    my $inds_ref_conf = shift;
    my $questions_ref = shift;
    my $questions_ref_conf = shift;
    my $attrs_ref = shift;
    my $attrs_ref_conf = shift;

    my $mnemo = $raw_qm->{"mnemo"};
    my $coef;

    # Are we in a leaf?
    if (exists($raw_qm->{"children"})) {
	# No: we have children beneath.
	my @children = @{$raw_qm->{"children"}};
	my @coefs;
	my $tmp_m_total;
	my $tmp_m_ok;
	my $full_weight;
	foreach my $child (@children) {
	    my $child_value = &aggregate_inds($child, $values, 
					      $inds_ref, $inds_ref_conf, 
					      $questions_ref, $questions_ref_conf, 
					      $attrs_ref, $attrs_ref_conf);
	    $tmp_m_total += $child->{"m_total"};
	    $tmp_m_ok += $child->{"m_ok"};
	    if (defined($child_value)) {
		if (exists($child->{"weight"})) {
		    $full_weight += $child->{"weight"};
		    push(@coefs, $child_value * $child->{"weight"});
		} else {
		    # Default value for weight is 1.
		    $full_weight += 1; 
		    push(@coefs, $child_value) if (defined($child_value));
		}
	    }
	}

	# Only store indicator if it is not null
	if ((scalar @coefs) != 0) {
	    my $sum;
	    map { $sum += $_ } @coefs;
	    
	    $coef = $sum / $full_weight;
	    my $coef_round = int($coef);
	    $raw_qm->{"ind"} = $coef_round;
	    $coef = $coef_round;
	}

	# Compute the number of metrics: total, available.
	$raw_qm->{"m_total"} = $tmp_m_total;
	$raw_qm->{"m_ok"} = $tmp_m_ok;
	
    } else {
	# Yes: compute the ind value of leaf.
#	print "DBG before compute_scale: for $mnemo.\n";
	$coef = &compute_scale($values->{$mnemo}, $flat_metrics{$mnemo}{"scale"});
	$raw_qm->{"ind"} = $coef;

	# Increment the total number of metrics used for this node.
	$raw_qm->{"m_total"}++;
	# If metric is defined also increment m_ok
	if (defined($coef)) {
	    $raw_qm->{"m_ok"} = 1;
	} else {
	    $raw_qm->{"m_ok"} = 0;
	}
	
    }

    my $confidence = $raw_qm->{"m_ok"} . " / " . $raw_qm->{"m_total"};

    # Populate hashes of values for indicators, questions, attributes.
    if (defined($coef)) {
	if ($raw_qm->{"type"} =~ m!attribute!) {
	    $attrs_ref->{$mnemo} = $coef;
	    $attrs_ref_conf->{$mnemo} = $confidence;
	} elsif ($raw_qm->{"type"} =~ m!concept!) {
	    $questions_ref->{$mnemo} = $coef;
	    $questions_ref_conf->{$mnemo} = $confidence;
	} elsif ($raw_qm->{"type"} =~ m!metric!) {
	    $inds_ref->{$mnemo} = $coef;
	    $inds_ref_conf->{$mnemo} = $confidence;
	}
    }
    
    my $tmp_coef = $coef || "undef";
    print "    - Computed [$tmp_coef] [$mnemo].\n" if ($debug);

    return $coef;
}


sub generate_inds($$$) {
    my $self = shift;
    my $project_id = shift;
    my $file_qm = shift;
    my $values = shift;
    my $dir_out_projects = shift;

    print "  * Generating project data for [$project_id] from [$file_qm] and values in [$dir_out_projects].\n";

    my $raw_qm = &read_json($file_qm);

    my %project_indicators;
    my %project_indicators_conf;
    my %project_questions;
    my %project_questions_conf;
    my %project_attrs;
    my %project_attrs_conf;

    print "    - Aggregating data from leaves up to attributes.\n";
    &aggregate_inds($raw_qm->{"children"}->[0], $values, 
		    \%project_indicators, \%project_indicators_conf, 
		    \%project_questions, \%project_questions_conf, 
		    \%project_attrs, \%project_attrs_conf);

    print "    - Generating project indicators..\n";
    &generate_downloads($project_id, 'indicators', $dir_out_projects, \%project_indicators);
#    &generate_downloads($project_id, 'indicators', $dir_out_projects, \%project_indicators_conf);

    print "    - Generating project questions..\n";
    &generate_downloads($project_id, 'questions', $dir_out_projects, \%project_questions);
    &generate_downloads($project_id, 'questions_confidence', $dir_out_projects, \%project_questions_conf);

    print "    - Generating project attributes..\n";
    &generate_downloads($project_id, 'attributes', $dir_out_projects, \%project_attrs);
    &generate_downloads($project_id, 'attributes_confidence', $dir_out_projects, \%project_attrs_conf);

    &populate_qm($raw_qm->{"children"}, 
		 \%project_attrs, 
		 \%project_questions, 
		 $values, 
		 \%project_indicators);

    # And write json file with full qm for visualisation
    my $out_json = $dir_out_projects . "/${project_id}_qm.json";
    print "    - Writing qm JSON to file [$out_json]..\n";    
    open(my $fh, '>', $out_json) or die "Could not open file '$out_json' $!";
    print $fh encode_json($raw_qm);
    close $fh;
}


# Import measures files for project and write a single
# file including all metrics in the projects/ directory
#
sub generate_project_metrics($$$) {
    my $self = shift;
    my $project_id = shift;
    my $project_from = shift;
    my $dir_out_projects = shift;

    print "  * Generating single metric file for [$project_id] from [$project_from] in [$dir_out_projects].\n";

    my %project_values;
    
    # We read metrics from all files named "*_metrics*.json"
    my @json_metrics_files = <${project_from}/${project_id}*metrics*.json>;
    for my $file (@json_metrics_files) {
	print "    - Reading metrics values file from [$file]..\n";    
	
	my $raw_values = &read_json($file);
	
	# We want to be able to read files from bitergia (raw) AND
	# from our scripts (extended).
	if (exists($raw_values->{"name"})) {
	    # Our format 
	    foreach my $metric (sort keys %{$raw_values->{"children"}}) {
		$project_values{uc($metric)} = $raw_values->{"children"}->{$metric};
	    }
	} else {
	    print "WARN Deprecated format for metrics values file [$file]. Reading anyway.\n" if ($debug);
	    # Bitergia format
	    foreach my $metric (keys %{$raw_values}) {
		$project_values{uc($metric)} = $raw_values->{$metric};
	    }        
	}
    }
    
    &generate_downloads($project_id, 'metrics', $dir_out_projects, \%project_values);

    return \%project_values;
}


sub generate_project($$$) {
    my $class = shift;
    my $project_path = shift;
    my $dir_out_projects = shift;
    my $qm_file = shift;

    my @path = File::Spec->splitdir($project_path);
    my $project_id = $path[-1];

    # Import PMI file
    my %project_pmi;
    my $pmi_ok = 0;
    my $path_pmi = $project_path . "/" . $project_id . "_pmi.json";
    print "    - Reading PMI file from [$path_pmi].. ";    
    if ( -f $path_pmi ) {
        print " Exists, OK.\n";
	my $json_pmi = &read_json($path_pmi);
	# Retrieve project information from the array
	my @projects_pmi = keys( $json_pmi->{"projects"} );
	my $project = $json_pmi->{"projects"}->{$projects_pmi[0]};
	$project_pmi{'title'} = $project->{"title"};
	$project_pmi{'desc'} = $project->{"description"}->[0]->{"safe_value"} || "";
	$project_pmi{'web'} = $project->{"website_url"}->[0]->{"url"} || "";
	$project_pmi{'wiki'} = $project->{"wiki_url"}->[0]->{"url"} || "";
	$project_pmi{'dl'} = $project->{"download_url"}->[0]->{"url"} || "";
	$project_pmi{'doc'} = $project->{"documentation_url"}->[0]->{"url"} || "";
	$project_pmi{'gs'} = $project->{"gettingstarted_url"}->[0]->{"url"} || "";
	$pmi_ok = 1;
    } else {
	my $err = "ERR: Cannot find PMI file [$path_pmi] for [$project_id].";
	push( @{$project_errors{$project_id}}, $err);
        print "\n$err\n";
    }

    # Import attributes file for project

    # We read attributes from file named "<project>_attributes.json"
    my $attrs_ok = 0;
    my $json_attrs = "${dir_out_projects}/${project_id}_attributes.json";
    my $json_attrs_conf = "${dir_out_projects}/${project_id}_attributes_confidence.json";
    my $html_ret_attrs = "";
    my %project_attrs;
    my %project_attrs_conf;
    if (-e $json_attrs) {
        print "    - Reading attributes from [$json_attrs]..\n";    
    
	my $raw_attrs = &read_json($json_attrs);
	my $raw_attrs_conf = &read_json($json_attrs_conf);

	$html_ret_attrs .= "<table class=\"table table-striped table-condensed table-hover\">\n";
	$html_ret_attrs .= "<tr><th width=\"40%\">Name</th>" 
	    . "<th width=\"20%\">Mnemo</th>" 
	    . "<th width=\"20%\">Value (confidence)</th>" 
	    . "<th width=\"20%\">Indicator</th></tr>\n";
	foreach my $a_mnemo (sort keys %{$raw_attrs->{"children"}}) {
	    my $a_value = $raw_attrs->{"children"}->{$a_mnemo};
	    my $a_conf = $raw_attrs_conf->{"children"}->{$a_mnemo};
	    $project_attrs{$a_mnemo} = $a_value || 0;
	    $project_attrs_conf{$a_mnemo} = $a_conf || 0;
	    if (exists($flat_attributes{$a_mnemo})) {
		$html_ret_attrs .= "<tr><td><a href=\"/documentation/attributes.html#" 
		    . $a_mnemo . '">' . $flat_attributes{$a_mnemo}{'name'} . "</a></td><td>" ;
		$html_ret_attrs .= "<a href=\"/documentation/attributes.html#" 
		    . $a_mnemo . '">' . $a_mnemo . "</a></td><td>";
		$html_ret_attrs .= "" . $a_value . " ( ${a_conf} metrics ) </td>";
		$html_ret_attrs .= "<td><span class=\"label label-scale\" style=\"background-color: " 
		    . $colours[$a_value] . "\">" . $a_value . "</span></td></tr>\n";
	    } else {
		my $err = "WARN: attribute [" . $a_mnemo . 
		    "] is not referenced in attributes definition file.\n";
		push( @{$project_errors{$project_id}}, $err);
		if ($debug) {
		    print $err;
		}
	    }
	}

	$html_ret_attrs .= "</table>\n";
	
#	&generate_downloads($project_id, 'attributes', $dir_out_projects, \%project_attrs);

	$html_ret_attrs .= "\n";
	$attrs_ok = 1;
    } else {
	my $err = "ERR: Cannot find attributes file [$json_attrs] for [$project_id].\n";
	push( @{$project_errors{$project_id}}, $err);
        print $err;
    }

    # Import questions file for project

    # We read questions from file named "<project>_questions.json"
    my $questions_ok = 0;
    my $json_questions = "${dir_out_projects}/${project_id}_questions.json";
    my $html_ret_questions = "";
    my %project_questions;
    if (-e $json_questions) {
        print "    - Reading questions from [$json_questions]..\n";    
    
        my $raw_questions = &read_json($json_questions);

	$html_ret_questions .= "<table class=\"table table-striped table-condensed table-hover\">\n";
	$html_ret_questions .= "<tr><th width=\"40%\">Name</th>" 
	    . "<th width=\"20%\">Mnemo</th>" 
	    . "<th width=\"20%\">Value</th>"
	    . "<th width=\"20%\">Indicator</th></tr>\n";
	foreach my $q_mnemo (sort keys %{$raw_questions->{"children"}}) {
	    my $q_value = $raw_questions->{"children"}->{$q_mnemo};
	    $project_questions{$q_mnemo} = $q_value;
	    if (exists($flat_questions{$q_mnemo})) {
		$html_ret_questions .= "<tr><td><a href=\"/documentation/questions.html#" 
		    . $q_mnemo . '">' . $flat_questions{$q_mnemo}{'name'} . "</a></td><td>" ;
		$html_ret_questions .= "<a href=\"/documentation/questions.html#" 
		    . $q_mnemo . '">' . $q_mnemo . "</a></td><td>";
		$html_ret_questions .= "" . $q_value . "</td>";
		$html_ret_questions .= "<td><span class=\"label label-scale\" style=\"background-color: " 
		    . $colours[$q_value] . "\">" . $q_value . "</span></td></tr>\n";
	    } else {
		my $err = "WARN: question [" . $q_mnemo . 
		    "] is not referenced in questions definition file.\n";
		push( @{$project_errors{$project_id}}, $err);
		if ($debug) {
		    print $err;
		}
	    }
	}

	$html_ret_questions .= "</table>\n";
	
#	&generate_downloads($project_id, 'questions', $dir_out_projects, \%project_questions);

	$html_ret_questions .= "\n";
	$questions_ok = 1;
    } else {
	my $err = "ERR: Cannot find questions file [$json_attrs] for [$project_id].\n";
	push( @{$project_errors{$project_id}}, $err);
        print $err;
    }

    # XXX
    # Read metrics from single file produced before.
    my $metrics_ok = 0;
    my $json_metrics = "${dir_out_projects}/${project_id}_metrics.json";
    my $json_indicators = "${dir_out_projects}/${project_id}_indicators.json";
    my $html_ret_values = "";
    my %project_values;
    my %project_indicators;

    if (-e $json_metrics) {
        print "    - Reading metrics from [$json_metrics]..\n";    
    
        my $raw_metrics = &read_json($json_metrics);
	%project_values = %{$raw_metrics->{"children"}};
        my $raw_indicators = &read_json($json_indicators);
	%project_indicators = %{$raw_indicators->{"children"}};

	$html_ret_values .= "<table class=\"table table-striped table-condensed table-hover\">\n";
	$html_ret_values .= "<tr><th width=\"40%\">Name</th>" 
	    . "<th width=\"20%\">Mnemo</th>" 
	    . "<th width=\"20%\">Value</th>"
	    . "<th width=\"20%\">Indicator</th></tr>\n";
	foreach my $m_mnemo (sort keys %{$raw_metrics->{"children"}}) {
	    my $m_value = $raw_metrics->{"children"}->{$m_mnemo};
	    my $m_ind = $raw_indicators->{"children"}->{$m_mnemo} || 0;
	    $project_values{$m_mnemo} = $m_value;

	    if (exists($flat_metrics{$m_mnemo})) {
		my $m_name = $flat_metrics{$m_mnemo}->{"name"};
		$html_ret_values .= "<tr><td><a href=\"/documentation/metrics.html#" 
		    . $m_mnemo . "\">" . $m_name . "</a></td>" ;
		$html_ret_values .= "<td><a href=\"/documentation/metrics.html#" 
		    . $m_mnemo . "\">" . $m_mnemo . "</a></td>";
		$html_ret_values .= "<td>" . $project_values{$m_mnemo} . "</td>";
		if (defined($flat_metrics{$m_mnemo}{"active"}) && $flat_metrics{$m_mnemo}{"active"} =~ m!true!) {
		    my $ind = $project_indicators{$m_mnemo};
		    $html_ret_values .= "<td><span class=\"label label-scale\" style=\"background-color: " 
			. $colours[$ind] . "\">" . $ind . "</span></td></tr>\n";
		} else {
		    $html_ret_values .= "<td><span class=\"label label-scale\" style=\"background-color: " 
			. "lightgray\"> Not Active </span></td></tr>\n";
		}
	    } else {
		my $err = "INFO: metric [" . $m_mnemo . 
		    "] is not referenced in metrics definition file.\n";
		push( @{$project_errors{$project_id}}, $err);
		if ($debug) {
		    print $err;
		}
	    }
	}

	$html_ret_values .= "</table>\n";
	$html_ret_values .= "\n";
	$metrics_ok = 1;
    } else {
	my $err = "ERR: Cannot find metrics file [$json_attrs] for [$project_id].\n";
	push( @{$project_errors{$project_id}}, $err);
        print $err;
    }


    # Import Rules file for project
    # We read rules from file named "<project>_violations.json"
    my $rules_ok = 0;
    my $json_violations = "${project_path}/${project_id}_violations.json";
    my $html_ret_rules = "";

    if (-e $json_violations) {
        print "    - Reading rules violations from [$json_violations]..\n";    
    
        my $raw_rules = &read_json($json_violations);

	# loop through values and display them in a table.
	$html_ret_rules .= "<table class=\"table table-striped table-condensed table-hover\">\n";
	$html_ret_rules .= "<tr><th width=\"40%\">Name</th>" 
	    . "<th width=\"40%\">Mnemo</th>" 
	    . "<th width=\"20%\">NCC</th></tr>\n";
	foreach my $rule (@{$raw_rules->{"children"}}) {
	    if (exists($flat_rules{$rule->{"name"}})) {
		my $v_mnemo = $rule->{'name'};
		$html_ret_rules .= "<tr><td><a href=\"/documentation/rules.html#" 
		    . $v_mnemo . '">' . $flat_rules{$v_mnemo}{'name'} . "</a></td>" ;
		$html_ret_rules .= "<td><a href=\"/documentation/rules.html#" 
		    . $v_mnemo . '">' . $v_mnemo . "</a></td>";
		$html_ret_rules .= "<td>" . $rule->{'value'} . "</td></tr>\n";
	    } else {
		my $err = "WARN: metric [" . $rule->{'name'} . 
		    "] is not referenced in metrics definition file.";
		push( @{$project_errors{$project_id}}, $err);
		print "$err\n" if ($debug);
	    }
	}

	$html_ret_rules .= "</table>\n";
	$rules_ok = 1;
    } else {
	my $err = "ERR: Cannot find violations file [$json_violations] for [$project_id].";
	push( @{$project_errors{$project_id}}, $err);
        print "$err\n";
    }
    

    # Create tabs
    my $html_ret = '
        <div id="page-wrapper">
          <div class="row">
            <div class="col-lg-12">
              <h2>Project ' . $project_id . '</h2>

              <div class="tabbable">
                <ul class="nav nav-tabs" role="tablist">
                  <li role="presentation" class="active"><a href="#home" role="tab" data-toggle="tab">Summary</a></li>';

    $html_ret .= '
                  <li role="presentation" class=""><a href="#qm" role="tab" data-toggle="tab">QM</a></li>';

    if ($attrs_ok) {
	$html_ret .= '
                  <li role="presentation"><a href="#attrs" role="tab" data-toggle="tab">Attributes</a></li>';
    } else { 
	$html_ret .= '
                  <li role="presentation" class="disabled"><a href="#attrs" role="tab" data-toggle="tab">Attributes</a></li>';
    }

    if ($questions_ok) {
	$html_ret .= '
                  <li role="presentation"><a href="#questions" role="tab" data-toggle="tab">Questions</a></li>';
    } else { 
	$html_ret .= '
                  <li role="presentation" class="disabled"><a href="#questions" role="tab" data-toggle="tab">Questions</a></li>';
    }

    if ($metrics_ok) {
	$html_ret .= '
                  <li role="presentation"><a href="#metrics" role="tab" data-toggle="tab">Metrics</a></li>';
    } else { 
	$html_ret .= '
                  <li role="presentation" class="disabled"><a href="#metrics" role="tab" data-toggle="tab">Metrics</a></li>';
    }

    if ($rules_ok) {
	$html_ret .= '
                  <li role="presentation"><a href="#practices" role="tab" data-toggle="tab">Practices</a></li>';
    } else { 
	$html_ret .= '
                  <li role="presentation" class="disabled"><a href="#practices" role="tab" data-toggle="tab">Practices</a></li>';
    }

    #                  <li role="presentation" class="disabled"><a href="#actions" role="tab" data-toggle="tab">Actions</a></li>

    $html_ret .= '
                  <li role="presentation" class="dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-expanded="false">
                    Download <span class="caret"></span></a>
                    <ul class="dropdown-menu" role="menu">
                      <li role="presentation"><a href="' . ${project_id} . '_attributes.json">Attributes JSON</a></li>
                      <li role="presentation"><a href="' . ${project_id} . '_attributes.csv">Attributes CSV</a></li>
                      <li role="presentation"><a href="' . ${project_id} . '_questions.json">Questions JSON</a></li>
                      <li role="presentation"><a href="' . ${project_id} . '_questions.csv">Questions CSV</a></li>
                      <li role="presentation"><a href="' . ${project_id} . '_metrics.json">Metrics JSON</a></li>
                      <li role="presentation"><a href="' . ${project_id} . '_metrics.csv">Metrics CSV</a></li>
                      <li role="presentation"><a href="' . ${project_id} . '_violations.csv">Violations JSON</a></li>
                      <li role="presentation"><a href="' . ${project_id} . '_attributes.csv">Violations CSV</a></li>
                    </ul>
                  </li>
                  <li role="presentation"><a href="#log" role="tab" data-toggle="tab">Errors</a></li>
                </ul>

                <!-- Tab panes -->
                <div class="tab-content">
                  <div role="tabpanel" class="tab-pane fade in active" id="home"><br />';

    # Start grid for summary header
    $html_ret .= '
                    <div class="row">
                      <div class="col-sm-6">
                        <dl class="dl-vertical">
                        <dt>Description</dt>
                        <dd>' . ($project_pmi{'desc'} || "") . '</dd>
                        </dl>
                      </div>
                      <div class="col-sm-6">
                      </div>
                    </div>
                    <div class="row">
                      <div class="col-sm-8">';

    # Display rating for project
    $html_ret .= '
                        <div class="panel panel-primary"><div class="panel-heading">'
	. 'Rating for main quality attributes</div>
                          <div class="panel-body">
                            <dl>'; 
    $html_ret .= &generate_progressbar("Overall Maturity", 
				       $project_attrs{"QM_QUALITY"}, 
				       $project_attrs_conf{"QM_QUALITY"}, 
				       $project_id);
    $html_ret .= &generate_progressbar("Ecosystem Quality",
				       $project_attrs{"QM_ECOSYSTEM"}, 
				       $project_attrs_conf{"QM_ECOSYSTEM"}, 
				       $project_id);
    $html_ret .= &generate_progressbar("Process Quality", 
				       $project_attrs{"QM_PROCESS"}, 
				       $project_attrs_conf{"QM_PROCESS"}, 
				       $project_id);
    $html_ret .= &generate_progressbar("Product Quality",
				       $project_attrs{"QM_PRODUCT"}, 
				       $project_attrs_conf{"QM_PRODUCT"}, 
				       $project_id);
    $html_ret .= '
                            </dl>
                          </div>
                        </div>
                      </div>';
    $html_ret .= '
                      <div class="col-sm-4">';
    
    # Display download box.
    $html_ret .= '
                        <div class="panel panel-primary"><div class="panel-heading">Summary</div>
                        <ul class="list-group">
                          <li class="list-group-item"><span class="glyphicon glyphicon-globe"></span> Web <a href="' . ($project_pmi{'web'} || "") . '">' . ($project_pmi{'web'} || "") . '</a></li>
                          <li class="list-group-item"><span class="glyphicon glyphicon-globe"></span> Wiki <a href="' . ($project_pmi{'wiki'} || "") . '">' . ($project_pmi{'wiki'} || "") . '</a></li>
                          <li class="list-group-item"><span class="glyphicon glyphicon-download"></span> Downloads <a href="' . ($project_pmi{'dl'} || "") . '">' . ($project_pmi{'dl'} || "") . '</a></li>
                          <li class="list-group-item"><span class="glyphicon glyphicon-question-sign"></span> Documentation <a href="' . ($project_pmi{'doc'} || "") . '">' . ($project_pmi{'doc'} || "") . '</a></dd>
                          <li class="list-group-item"><span class="glyphicon glyphicon-question-sign"></span> Getting Started <a href="' . ($project_pmi{'gs'} || "") . '">' . ($project_pmi{'gs'} || "") . '</a></dd>
                        </ul>
                        </div>';

    # Close grid (col & row) for summary header
    $html_ret .= '
                      </div>
                    </div>';   

    # Display sub-attributes
    $html_ret .= '
                    <div class="row">
                      <div class="col-sm-4">';

    # Display rating for project: ECOSYSTEM
    $html_ret .= '
                        <div class="panel panel-primary"><div class="panel-heading">'
	. 'Ecosystem quality</div>
                          <div class="panel-body">
                            <dl>'; 
    $html_ret .= &generate_progressbar('Activity',
				       $project_attrs{"QM_ACTIVITY"} || 0, 
				       $project_attrs_conf{"QM_ACTIVITY"} || 0,
				       $project_id);
    $html_ret .= &generate_progressbar('Diversity', 
				       $project_attrs{"QM_DIVERSITY"} || 0,  
				       $project_attrs_conf{"QM_DIVERSITY"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Responsiveness', 
				       $project_attrs{"QM_RESPONSIVENESS"} || 0,  
				       $project_attrs_conf{"QM_RESPONSIVENESS"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Support',
				       $project_attrs{"QM_SUPPORT"} || 0,  
				       $project_attrs_conf{"QM_SUPPORT"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Usage',
				       $project_attrs{"QM_USAGE"} || 0,  
				       $project_attrs_conf{"QM_USAGE"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('User feedback',
				       $project_attrs{"QM_FEEDBACK"} || 0,  
				       $project_attrs_conf{"QM_FEEDBACK"} || 0, 
				       $project_id);
    $html_ret .= '</dd>
                            </dl>
                          </div>
                        </div>
                      </div>';
    
    # Display rating for project: process
    $html_ret .= '
                      <div class="col-sm-4">';
    $html_ret .= '
                        <div class="panel panel-primary"><div class="panel-heading">'
	. 'Process quality</div>
                          <div class="panel-body">
                            <dl>'; 
    $html_ret .= &generate_progressbar('Configuration Management',
				       $project_attrs{"QM_SCM"} || 0,  
				       $project_attrs_conf{"QM_SCM"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Change Management',
				       $project_attrs{"QM_ITS"} || 0,  
				       $project_attrs_conf{"QM_ITS"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Planning Management',
				       $project_attrs{"QM_PLAN"} || 0,  
				       $project_attrs_conf{"QM_PLAN"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Test Management',
				       $project_attrs{"QM_TST"} || 0,  
				       $project_attrs_conf{"QM_TST"} || 0, 
				       $project_id);
    $html_ret .= '
                            </dl>
                          </div>
                        </div>
                      </div>';

    # Display rating for project: PRODUCT
    $html_ret .= '
                      <div class="col-sm-4">';
    $html_ret .= '
                        <div class="panel panel-primary"><div class="panel-heading">'
	. 'Product quality</div>
                          <div class="panel-body">
                            <dl>'; 
    $html_ret .= &generate_progressbar('Analysability',
				       $project_attrs{"QM_ANA"} || 0,  
				       $project_attrs_conf{"QM_ANA"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Changeability',
				       $project_attrs{"QM_CHA"} || 0,  
				       $project_attrs_conf{"QM_CHA"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Reliability',
				       $project_attrs{"QM_REL"} || 0,  
				       $project_attrs_conf{"QM_REL"} || 0, 
				       $project_id);
    $html_ret .= &generate_progressbar('Reusability',
				       $project_attrs{"QM_REU"} || 0,  
				       $project_attrs_conf{"QM_REU"} || 0, 
				       $project_id);
    $html_ret .= '
                            </dl>
                          </div>
                        </div>
                      </div>';

   # Close grid (row) for summary
    $html_ret .= '
                    </div>';   

 
    $html_ret .= '
                  </div>
                  <div role="tabpanel" class="tab-pane fade" id="qm">';

    print "    - Writing quality model for [$project_id].\n";
    $html_ret .= get_html_qm($project_id);

    $html_ret .= '
                  </div>
                  <div role="tabpanel" class="tab-pane fade" id="attrs"><br />';
    
    $html_ret .= $html_ret_attrs;

    $html_ret .= '
                  </div>
                  <div role="tabpanel" class="tab-pane fade" id="questions"><br />';

    $html_ret .= $html_ret_questions;

    $html_ret .= '
                  </div>
                  <div role="tabpanel" class="tab-pane fade" id="metrics"><br />';

    $html_ret .= $html_ret_values;
 
    $html_ret .= '</div>
                  <div role="tabpanel" class="tab-pane fade" id="practices"><br />';

    $html_ret .= $html_ret_rules;

    $html_ret .= '</div>
                  <div role="tabpanel" class="tab-pane fade" id="actions">...</div>
                  <div role="tabpanel" class="tab-pane fade" id="log"><br />
                    <ul class="list-group">';
    foreach my $logline (@{$project_errors{$project_id}}) {
	if ($logline =~ m!^ERR\s*:?(.*)$!) { 
	    $logline = "<span class=\"label label-danger\">ERROR</span> " . $1;
	}
	if ($logline =~ m!^WARN\s*:?!) { 
	    $logline = "<span class=\"label label-danger\">ERROR</span> " . $logline;
	}
	$html_ret .= '
                      <li class="list-group-item">' . $logline . '</li>';;
    }

    $html_ret .= '
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
';

    return $html_ret;
}

sub generate_all_projects($) {
    my $class = shift;
    
}


# Generate all documentation.

# Generate page for quality model attributes.
# Params: 
sub generate_doc_attributes($) {
    my $class = shift;

    my $file_attrs = shift;
    
    ## Read attributes file

    # Open attributes file and read.
    print "  * Reading attributes from file [$file_attrs]...\n";
    
    my $raw_attrs = &read_json($file_attrs);
    
    my $attrs_name = $raw_attrs->{"name"};
    my $attrs_version = $raw_attrs->{"version"};
    print "      Ruleset: [", $attrs_name, "],";
    print " version [", $attrs_version, "],";
    
    my $vol_attrs;
    foreach my $attr (@{$raw_attrs->{"children"}}) {
	$flat_attributes{$attr->{"mnemo"}} = $attr;
	$vol_attrs++;
    }

    print " [$vol_attrs] attributes found.\n";
    
    my $html_ret = '
        <div id="page-wrapper">
          <div class="row">
            <div class="col-lg-12">
              <h2>Definition of Attributes</h2>
              <p>Attributes of quality represent our measurement goals for the given context. The first step when defining attributes is to gather quality requirements, in this case both for the Eclipse foundation and the PolarSys working group. These have been summarised <a href="https://polarsys.org/wiki/EclipseQualityRequirements">on a dedicated page of the wiki</a>. We relied on different standards and norms to formalise them: ISO 9126 and 250xx for the product, CMMi for the process, and open-source quality models for the community. </p><br />
        
';
    
    $html_ret .= '
              <ul class="list-group">';

    foreach my $attr (sort keys %flat_attributes) {
        $html_ret .= '
                <li class="list-group-item">';
        my $attr_name = $flat_attributes{$attr}{"name"};
        my $attr_desc = $flat_attributes{$attr}{"desc"};

        $html_ret .= "<p id=\"$attr\"><strong>$attr_name</strong> ( $attr )</p>\n";
        foreach my $desc (@{$attr_desc}) {
            $html_ret .= "<p class=\"desc\">$desc</p>\n";
        }
        $html_ret .= '
                </li>';
    
    }

    $html_ret .= '
              </ul>';
        
    $html_ret .= '
            </div>
          </div>
        </div>';


    return $html_ret;
    
}



# describes a metric
# params: 
#   $ the mnemo of the metric
sub describe_metric($) {
    my $mnemo = shift;

    if (not exists $flat_metrics{$mnemo}) {
        die "Could not find metric (internal inconsistency).\n";
    }

    my $metric = $flat_metrics{$mnemo};
    my $metric_name = $metric->{"name"};
    my $metric_desc = $metric->{"desc"};
    my $metric_from = $metric->{"ds"};
    my $metric_active = $metric->{"active"};
    my $metric_scale = $metric->{"scale"};

    my $text = "<p id=\"$mnemo\"><strong>$metric_name</strong> ( $mnemo )</p>\n";

    if (defined($metric_active) && ($metric_active =~ m!true!)) {
	$text .= "<p class=\"desc\"><strong>Active</strong>: true</p>\n";
    } else {
	$text .= "<p class=\"desc\"><strong>Active</strong>: false</p>\n";
    }

    my @used_by;
    foreach my $parent (sort keys %{$metric->{"parents"}}) {
	push(@used_by, "<a href=\"questions.html#$parent\">" . $parent . "</a>\n");
    }
    my $used_by_str = join(', ', @used_by);

    $text .= "<p class=\"desc\"><strong>Used by</strong>: $used_by_str</p>\n";

    $text .= "<p class=\"desc\"><strong>Description</strong>:</p>\n";
    foreach my $desc (@{$metric_desc}) {
        $text .= "<p class=\"desc\">$desc</p>\n";
    }

    if (defined($metric_active) 
	&& ($metric_active =~ m!true!) 
	&& defined($metric_scale)) {
	my @scales;
	for (my $i = 0 ; $i < 4 ; $i++) {
	    my $is_sorted = &is_ordered_scale($metric_scale);
	    if ($is_sorted == 1) {
		push(@scales, "</span> &lt; " . $metric_scale->[$i] 
		     . " &le; <span class=\"label label-scale\" style=\"background-color: " 
		     . $colours[$i+2] . ";\"> " . (${i} + 2) . " ");
	    } elsif ($is_sorted == 0) {
		push(@scales, "</span> &gt; " . $metric_scale->[$i] 
		     . " &ge; <span class=\"label label-scale\" style=\"background-color: " 
		     . $colours[$i+2] . ";\"> " . (${i} + 2) . " ");
	    } else { }
	}
	my $scale_str = "<span class=\"label label-scale\" style=\"background-color: " . $colours[1] 
	    . "\"> 1 " . join(' ', @scales) . "</span>";
	$text .= "<p class=\"desc\"><strong>Scale</strong>: $scale_str</p>\n";
    }
    
    return $text;
} 


sub find_qm_node($$$$) {
    my $raw_qm_array = shift;
    my $type = shift;
    my $mnemo = shift;
    my $nodes_array = shift;
    my $father_mnemo = shift;

    foreach my $child (@{$raw_qm_array}) {
	if (($child->{"type"} eq $type) and ($child->{"mnemo"} eq $mnemo)) {
	    $child->{"father"} = $father_mnemo;
	    push(@{$nodes_array}, $child);
	    next;
	}
	if (exists($child->{"children"})) {
	    &find_qm_node($child->{"children"}, $type, $mnemo, $nodes_array, $child->{"mnemo"});
	} else {
	}
    }
}


sub generate_doc_metrics($) {
    my $class = shift;
    my $file_metrics = shift;
    my $qm_file = shift;
    
    ## Read metrics file

    # Open metrics file and read.
    print "  * Reading metrics file [$file_metrics]...\n";

    my $raw_metrics = &read_json($file_metrics);
    
    my $html_ret = '
        <div id="page-wrapper">
          <div class="row">
            <div class="col-lg-12">
              <h2>Definition of metrics</h2>
              <p>All metrics used in the maturity assessment process are described thereafter, with useful information and references.</p><br />
        
';

    
    print "    - Reading qm from [$qm_file].\n";
    my $raw_qm = &read_json($qm_file);

    # Import metrics.
    my $metrics_total;
    foreach my $tmp_metric (@{$raw_metrics->{"children"}}) {
        my $metric_mnemo = $tmp_metric->{"mnemo"};
        my $metric_ds = $tmp_metric->{"ds"};
	if (exists $flat_metrics{$metric_mnemo}) {
	    my $err = "WARN: Metric [$metric_mnemo] already exists!.";
	    push( @{$project_errors{'MAIN'}}, $err);
	    print "$err\n",
	} else {
	    $flat_metrics{$metric_mnemo} = $tmp_metric;
	}

	# Check if the metric is active in the qm 
	# XXX
	my @nodes_array;
	&find_qm_node($raw_qm->{"children"}, "metric", $metric_mnemo, \@nodes_array, "root");
	my %tmp_nodes;
	foreach my $node (@nodes_array) {
	    if (defined($node->{"father"})) {
		$tmp_nodes{$node->{"father"}}++;
	    } else {
		print "ERR: no father on " . $node->{"mnemo"} . "\n";
	    }

	    if ($node->{"active"} =~ m!true!i) { 
		$flat_metrics{$metric_mnemo}{"active"} = "true"; 
	    } else {
		$flat_metrics{$metric_mnemo}{"active"} = "false"; 
	    }
	}

	# Populate metrics_ds
	if ( defined($flat_metrics{$metric_mnemo}{"active"}) ) {
	    $metrics_ds{$metric_ds}++;
	    $metrics_total++;
	} 


	$flat_metrics{$metric_mnemo}{"parents"} = \%tmp_nodes;
    }
    
    # Create the tabs.
    $html_ret .= ' 
              <div class="tabbable">
                <ul class="nav nav-tabs" role="tablist">
                  <li role="presentation" class="active"><a href="#repo_all" role="tab" data-toggle="tab">All&nbsp;<span class="badge">' . 
                  $metrics_total . '</span></a></li>';

    foreach my $repo (sort keys %metrics_ds) {
        $html_ret .= '
                  <li role="presentation">
                    <a href="#repo_' . $repo . '" role="tab" data-toggle="tab">' . ucfirst($repo) . 
                    '&nbsp;<span class="badge">' . $metrics_ds{$repo} . '</span></a></li>';
    }

    $html_ret .= '
                </ul>
                <div class="tab-content">
                <div role="tabpanel" class="tab-pane fade in active" id="repo_all"><br />
                  <ul class="list-group">';
                  
    foreach my $tmp_metric (sort keys %flat_metrics) {
	if ( defined($flat_metrics{$tmp_metric}{"active"}) ) {
	    $html_ret .= '
                <li class="list-group-item">';
	    $html_ret .= &describe_metric($tmp_metric);
	    $html_ret .= "</li>";
	}
    }
    $html_ret .= '
                  </ul></div>';
    
    # Create tab contents
    foreach my $repo (sort keys %metrics_ds) {
        $html_ret .= '
                  <div role="tabpanel" class="tab-pane fade" id="repo_' . $repo . '"><br />';
        $html_ret .= '
                    <ul class="list-group">';
                  
        foreach my $tmp_metric (sort keys %flat_metrics) {
            if ( defined($flat_metrics{$tmp_metric}{"active"}) &&
		 $flat_metrics{$tmp_metric}->{"ds"} eq $repo ) {
            $html_ret .= '
                      <li class="list-group-item">';
            $html_ret .= &describe_metric($tmp_metric);
            $html_ret .= "</li>";
            }
        }
        $html_ret .= '
                    </ul>
                  </div>  ';
    }
    
    $html_ret .= '
              </div>
            </div>
          </div>
        </div>';


    return $html_ret;
}

sub generate_doc_questions($) {
    my $class = shift;
    my $file_questions = shift;
    
    ## Read question file

    # Open rules file and read.
    print "  * Reading questions from file [$file_questions]...\n";
    
    my $vol_questions;
    
    my $raw_questions = &read_json($file_questions);
    
    my $questions_name = $raw_questions->{"name"};
    my $questions_version = $raw_questions->{"version"};
    print "      Ruleset: [", $questions_name, "],";
    print " version [", $questions_version, "],";
    
    my $file_vol_questions;
    foreach my $question (@{$raw_questions->{"children"}}) {
	$flat_questions{$question->{"mnemo"}} = $question;
	$file_vol_questions++;
    }
    
    print " [$file_vol_questions] rules found.\n";
    
    my $html_ret = '
        <div id="page-wrapper">
          <div class="row">
            <div class="col-lg-12">
              <h2>Definition of Questions</h2>
              <p>Questions are mapped to quality attributes, on one side, and to metrics on the other side. It acts as a generic definition for measurement, allowing users to analyse different types of projects with the same quality tree. Questions also preserve the semantics and consistency of measures regarding associated the quality attribute, see Basili\'s Goal-Question-Metric approach [<a href="/documentation/references.html#Basili1994">Basili1994</a>] for more information on this approach.</p><br />
        
';
    
    $html_ret .= '
              <ul class="list-group">';

    foreach my $question (sort keys %flat_questions) {
        $html_ret .= '
                <li class="list-group-item">';
        my $question_name = $flat_questions{$question}{"name"};
        my $question_desc = $flat_questions{$question}{"desc"};
	my $question_question = "";
	if (exists $flat_questions{$question}{"question"}) {
	    $question_question = $flat_questions{$question}{"question"} ;
	}

        $html_ret .= "<p id=\"$question\"><strong>$question_name</strong> ( $question )</p>\n";
        $html_ret .= "<p class=\"desc\">" . $question_question . "</a>\n";
        foreach my $desc (@{$question_desc}) {
            $html_ret .= "<p class=\"desc\">$desc</p>\n";
        }
        $html_ret .= '
                </li>';
    
    }

    $html_ret .= '
              </ul>';
        
    $html_ret .= '
            </div>
          </div>
        </div>';


    return $html_ret;

}

sub generate_doc_rules($) {
    my $class = shift;
    my $dir_rules = shift;
    
    ## Read rules files

    # Open rules file and read.
    print "  * Reading rules from dir [$dir_rules]...\n";
    
    my @json_files = <$dir_rules/*.json>;

    my $vol_rules;
    foreach my $file_rules (@json_files) {
        
        print "    - Reading rules file $file_rules..\n";
        my $raw_rules = &read_json($file_rules);
        
        my $rules_name = $raw_rules->{"name"};
        my $rules_version = $raw_rules->{"version"};
        print "      Ruleset: [", $rules_name, "],";
        print " version [", $rules_version, "],";
        my $rules_from = $rules_name . " " . $rules_version;
        
        my $file_vol_rules;
        foreach my $rule_child (@{$raw_rules->{"children"}}) {
            $flat_rules{$rule_child->{"mnemo"}} = $rule_child;
            $flat_rules{$rule_child->{"mnemo"}}->{"from"} = $rules_from;
            $file_vol_rules++;
        }
        $vol_rules += $file_vol_rules;
        
        print " [$file_vol_rules] rules found.\n";
    }
    
    my $html_ret = '
        <div id="page-wrapper">
          <div class="row">
            <div class="col-lg-12">
              <h2>Definition of rules</h2>
              <p>Rules are mapped to good and bad practices, as defined by the open-source community. They are computed by open-source rule-checking tools like PMD or FindBugs. They are classified by category associated to some quality characteristics.</p><br />
        
';
    
    $html_ret .= '
              <ul class="list-group">';

    foreach my $rule_mnemo (sort keys %flat_rules) {
        $html_ret .= '
                <li class="list-group-item">';
        my $rule_name = $flat_rules{$rule_mnemo}{"name"};
        my $rule_desc = $flat_rules{$rule_mnemo}{"desc"};

        $html_ret .= "<p id=\"$rule_mnemo\"><strong>$rule_name</strong> ( $rule_mnemo )</p>\n";
        
        foreach my $desc (@{$rule_desc}) {
            $html_ret .= "<p class=\"desc\">$desc</p>\n";
        }
        $html_ret .= '
                </li>';
    
    }

    $html_ret .= '
              </ul>';
        
    $html_ret .= '
            </div>
          </div>
        </div>';


    return $html_ret;

}

sub generate_doc_refs($) {
    my $class = shift;
    my $file_refs = shift;
    
    ## Read refs file

    # Open references file and read.
    print "  * Reading references from [$file_refs]...\n";

    my $raw_refs = &read_json($file_refs);
    
    # Import references.
    foreach my $tmp_ref (keys %{$raw_refs->{"children"}}) {
        $flat_refs{$tmp_ref} = $raw_refs->{"children"}->{$tmp_ref};
    }
    
    my $html_ret = '
        <div id="page-wrapper">
          <div class="row">
            <div class="col-lg-12">
              <h2>References</h2>
              <p>All refs used in the maturity assessment process are described thereafter, with useful information and references.</p><br />
        
';
    
    $html_ret .= '
              <ul class="list-group">';

    foreach my $ref (sort keys %flat_refs) {
    my $ref_desc = $flat_refs{$ref};
        $html_ret .= '
                <li class="list-group-item">';
        $html_ret .= "<p id=\"$ref\"><strong>[$ref]</strong> $ref_desc</p></li>\n";
    
    }

    $html_ret .= '
              </ul>';
        
    $html_ret .= '
            </div>
          </div>
        </div>';


    return $html_ret;
}

1;
