<!DOCTYPE html><body>
<link rel="stylesheet" type="text/css" href="styles.css"/>
<h1>List of rules for the PolarSys Maturity Assessment quality model</h1>
<h4>Avoid Reassigning Parameters (AvoidReassigningParameters)</h4>
<p class="desc">Category: CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Reassigning values to incoming parameters is not recommended. Use temporary local variables instead.</p>
<p class="desc">This rule impacts changeability, since the maintainer may assume that the parameters contain the passed values.</p>
<h4>Use Varargs (UseVarargs)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Java 5 introduced the varargs parameter declaration for methods and constructors. This syntactic sugar provides flexibility for users of these methods and constructors, allowing them to avoid having to deal with the creation of an array.</p>
<p class="desc">This rule impacts analysability, since varargs were intended to be easier to read than arrays.</p>
<h4>Final Field Could Be Static (FinalFieldCouldBeStatic)</h4>
<p class="desc">Category: EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">If a final field is assigned to a compile-time constant, it could be made static, thus saving overhead in each object at runtime.</p>
<p class="desc">This rule impacts resources usage, because of the overhead of the non-static field.</p>
<h4>LawOfDemeter (LawOfDemeter)</h4>
<p class="desc">Category: REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">The Law of Demeter is a simple rule, that says 'only talk to friends'. It helps to reduce coupling between classes or objects. See also the references: Andrew Hunt, David Thomas, and Ward Cunningham. The Pragmatic Programmer. From Journeyman to Master. Addison-Wesley Longman, Amsterdam, October 1999.; K.J. Lieberherr and I.M. Holland. Assuring good style for object-oriented programs. Software, IEEE, 6(5):38â€“48, 1989.; http://www.ccs.neu.edu/home/lieber/LoD.html; http://en.wikipedia.org/wiki/Law_of_Demeter .</p>
<p class="desc">This rule can detect possible violations of the Law of Demeter. The Law of Demeter is a simple rule, that says 'only talk to friends'. It helps to reduce coupling between classes or objects.</p>
<p class="desc">This rule impacts reusability, since many classes need to be available for this class to work.</p>
<h4>Empty Synchronized Block (EmptySynchronizedBlock)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Empty synchronized blocks serve no purpose and should be removed.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>Empty Static Initializer (EmptyStaticInitializer)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">An empty static initializer serve no purpose and should be removed.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>Check SkipResult (CheckSkipResult)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">The <code>skip()</code> method may skip a smaller number of bytes than requested. Check the returned value to find out if it was the case or not.</p>
<p class="desc">This rule impacts reliability, since the call may not have produced the intended result.</p>
<h4>Simple Date Format Needs Locale (SimpleDateFormatNeedsLocale)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Be sure to specify a Locale when creating SimpleDateFormat instances to ensure that locale-appropriate formatting is used.</p>
<p class="desc">This rule impacts reliability, since it may produce an unpredictable behaviour for different locales.</p>
<h4>Empty Statement Block (EmptyStatementBlock)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Empty finally blocks serve no purpose and should be removed.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>BigInteger Instantiation (BigIntegerInstantiation)</h4>
<p class="desc">Category: </p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Don't create instances of already existing BigInteger (BigInteger.ZERO, BigInteger.ONE) and for Java 1.5 onwards, BigInteger.TEN and BigDecimal (BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN).</p>
<p class="desc"></p>
<h4>Equals Null (EqualsNull)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Tests for null should not use the equals() method, since it will throw an exception if the variable is null instead of going in the loop. The '==' operator should be used instead.</p>
<p class="desc">This rule impacts reliability, since a NullPointerException may be thrown if the variable is indeed null.</p>
<p class="desc">TODO: not sure this rule is widely used.</p>
<h4>Coupling Between Objects (CouplingBetweenObjects)</h4>
<p class="desc">Category: REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">This rule counts the number of unique attributes, local variables, and return types within an object. A number higher than the specified threshold can indicate a high degree of coupling. The default value is set to 20.</p>
<p class="desc">CouplingBetweenObjects attempts to capture all unique Class attributes, local variables, and return types to determine how many objects a class is coupled to. This is only a gauge and isn't a hard and fast rule. The threshold value is configurable and should be determined accordingly.</p>
<p class="desc">This rule impacts reusability, since many classes need to be available for this class to work.</p>
<h4>Avoid ThreadGroup (AvoidThreadGroup)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid using java.lang.ThreadGroup; although it is intended to be used in a threaded environment it contains methods that are not thread-safe.</p>
<p class="desc">This pattern impacts the reliability, since a non-thread-safe method may be invoked in a threaded environment.</p>
<h4>Avoid Constants Interface (AvoidConstantsInterface)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">An interface should be used only to characterize the external behaviour of an implementing class: using an interface as a container of constants is a poor usage pattern and not recommended.</p>
<p class="desc">This rule impacts analysability, since the maintainer may have trouble understanding why the class is declared as an interface.</p>
<h4>Non Thread Safe Singleton (NonThreadSafeSingleton)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Non-thread safe singletons can result in bad state changes. Eliminate static singletons if possible by instantiating the object directly. Static singletons are usually not needed as only a single instance exists anyway. Other possible fixes are to synchronize the entire method or to use an initialize-on-demand holder class (do not use the double-check idiom). See Effective Java, item 48.</p>
<p class="desc">This rule impacts reliability, since bad state changes may induce an unpredictable behaviour.</p>
<h4>UseUtilityClass (UseUtilityClass)</h4>
<p class="desc">Category: REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">For classes that only have static methods, consider making them utility classes. Note that this doesn't apply to abstract classes, since their subclasses may well include non-static methods. Also, if you want this class to be a utility class, remember to add a private constructor to prevent instantiation. (Note, that this use was known before PMD 5.1.0 as UseSingleton).</p>
<p class="desc">This rule impacts reusability, since making the class a utility would ease its access and usage.</p>
<h4>Close Resource (CloseResource)</h4>
<p class="desc">Category: EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed after use.</p>
<p class="desc">Makes sure you close your database connections. It does this by looking for code patterned like this: Connection c = X; try { // do stuff, and maybe catch something } finally { c.close(); }</p>
<p class="desc">This rule impacts resources usage, since unneeded open connections take some memory and cpu.</p>
<h4>Missing Break In Switch (MissingBreakInSwitch)</h4>
<p class="desc">Category: REL CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Switch statements without break or return statements for each case option may indicate problematic behaviour. Empty cases are ignored as these indicate an intentional fall-through.</p>
<p class="desc">This rule impacts reliability, since an unpredictable behaviour may arise when unintendedly falling through the next case. It also impacts changeability, since introducing a new case may modify the behaviour of the previous one.</p>
<h4>Empty Initializer (EmptyInitializer)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">Empty block statements serve no purpose and should be removed.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>Uncommented Empty Method (UncommentedEmptyMethod)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Uncommented Empty Method finds instances where a method does not contain statements, but there is no comment. By explicitly commenting empty methods it is easier to distinguish between intentional (commented) and unintentional empty methods.</p>
<p class="desc">This rule impacts analysability, since the maintainer does not know if the empty method was really intended and useful.</p>
<h4>Compare Objects With Equals (CompareObjectsWithEquals)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Use equals() to compare object references; avoid comparing them with ==.</p>
<p class="desc">This rule impacts reliability, since the == operator is not consistent over all types of objects and an exception may arise.</p>
<p class="desc">TODO: This rule also includes Enum's, which is wrong -- comparing Enums with equal might even considered good practice. See http://sourceforge.net/p/pmd/bugs/909/</p>
<h4>Avoid Deeply Nested If Statements (AvoidDeeplyNestedIfStmts)</h4>
<p class="desc">Category: ANA CHA TES</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid creating deeply nested if-then statements since they are harder to read and error-prone to maintain. The nesting threshold can be configured by the user, default value is 3.</p>
<p class="desc">This rule impacts analysability, since deeply nested control structure are hard to understand past a given threshold. It also impacts changeability, since a maintainer will need to check the whole structure to apply a change. It also impacts testability, since it increases the number of paths to check.</p>
<h4>Class With Only Private Constructors Should Be Final (ClassWithOnlyPrivateConstructorsShouldBeFinal)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">A class with only private constructors should be final, unless the private constructor is invoked by a inner class.</p>
<p class="desc">This rule impacts analysability, since the maintainer will have trouble understanding the intent of the class.</p>
<h4>Logic Inversion (LogicInversion)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Use opposite operator instead of negating the whole expression with a logic complement operator.</p>
<p class="desc">This rule impacts analysability, since it is easier to read a condition than its negation.</p>
<h4>Empty Catch Block (EmptyCatchBlock)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Empty Catch Block finds instances where an exception is caught, but nothing is done. In most circumstances, this swallows an exception which should either be acted on or reported.</p>
<p class="desc">This rule impacts reliability, since nothing is done about the exception and unpredictable behaviour may occur.</p>
<h4>Field Declarations Should Be At Start Of Class (FieldDeclarationsShouldBeAtStartOfClass)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes. </p>
<p class="desc">This rule impacts analysability, since most people will assume that all declarations are done at the start of the class.</p>
<h4>Boolean Instantiation (BooleanInstantiation)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 2</p>
<p class="desc">Description:</p>
<p class="desc">Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf() instead.</p>
<p class="desc">Boolean instantiation adds unnecessary complexity and clutters the code.</p>
<h4>Simplify Conditional (SimplifyConditional)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.</p>
<p class="desc">This rule impacts analysability, since the pattern implies unnecessary code.</p>
<h4>Assignment To Non Final Static (AssignmentToNonFinalStatic)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Identifies a possible unsafe usage of a static field.</p>
<p class="desc">This rule impacts reliability, since the variable may be modified by another calls, producing an unpredictable behaviour.</p>
<h4>Unused Private Field (UnusedPrivateField)</h4>
<p class="desc">Category: ANA EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Detects when a private field is declared and/or assigned a value, but not used.</p>
<p class="desc">This rule impacts analysability, since the maintainer will not understand why this field is declared. It also impacts resources, since there is an unused declared field.</p>
<h4>Non Case Label In Switch Statement (NonCaseLabelInSwitchStatement)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">A non-case label (e.g. a named break/continue label) was present in a switch statement. This is legal, but confusing. It is easy to mix up the case labels and the non-case labels.</p>
<p class="desc">This rule impacts analysability, since this may confuse the maintainer when reading the switch. By the way, introducing a label <i>in</i> the switch creates an intricate control flow and is discouraged.</p>
<h4>Unused Local Variable (UnusedLocalVariable)</h4>
<p class="desc">Category: ANA EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Detects when a local variable is declared and/or assigned, but not used.</p>
<p class="desc">This rule impacts analysability, since the maintainer will not understand why this variable is declared. It also impacts resources, since there is an unused declared variable.</p>
<h4>For Loop Should Be While Loop (ForLoopShouldBeWhileLoop)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Some for loops can be simplified to while loops, this makes them more concise.</p>
<p class="desc">A maintainer will wonder why a for loop is used without condition. While loops are also more concise.</p>
<h4>Empty While Stmt (EmptyWhileStmt)</h4>
<p class="desc">Category: ANA EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Empty While Statement finds all instances where a while statement does nothing. If it is a timing loop, then you should use Thread.sleep() for it; if it is a while loop that does a lot in the exit expression, rewrite it to make it clearer.</p>
<p class="desc">This rule impacts analysability, since it introduces unnecessary code. It also impacts resources, since it takes unnecessary space and cpu.</p>
<h4>Empty Try Block (EmptyTryBlock)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid empty try blocks - there do nothing and just clutter the code.</p>
<p class="desc">This rule impacts analysability, since it introduces unnecessary code.</p>
<h4>Too Few Branches For A Switch Statement (TooFewBranchesForASwitchStatement)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Switch statements are indended to be used to support complex branching behaviour. Using a switch for only a few cases is ill-advised, since switches are not as easy to understand as if-then statements. In these cases use the if-then statement to increase code readability. Default value is 3 and above.</p>
<p class="desc">This rule impacts analysability, since the switch statement is more difficult to read than a simple if-then.</p>
<h4>Use Collection isEmpty (UseCollectionIsEmpty)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">The isEmpty() method on java.util.Collection is provided to determine if a collection has any elements. Comparing the value of size() to 0 does not convey intent as well as the isEmpty() method.</p>
<p class="desc">This rule impacts analysability, since the intent is much clearer for the maintainer.</p>
<h4>Dont Call ThreadRun (DontCallThreadRun)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 4</p>
<p class="desc">Description:</p>
<p class="desc">Explicitly calling Thread.run() method will execute in the caller's thread of control. Instead, call Thread.start() for the intended behavior.</p>
<p class="desc">This rule impacts analysability, since a maintainer will have trouble understanding the intended behaviour.</p>
<h4>Return Empty Array Rather Than Null (ReturnEmptyArrayRatherThanNull)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">For any method that returns an array, it is a better to return an empty array rather than a null reference. This removes the need for null checking all results and avoids inadvertent NullPointerExceptions. </p>
<p class="desc">This rule impacts reliability, since a NullPointerException may arise from the method's caller.</p>
<h4>Avoid Branching Statement As Last In Loop (AvoidBranchingStatementAsLastInLoop)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 2</p>
<p class="desc">Description:</p>
<p class="desc">Using a branching statement as the last part of a loop may be a bug, and/or is confusing. Ensure that the usage is not a bug, or consider using another approach.</p>
<p class="desc">This pattern impacts analysability, since the maintainer will have trouble understanding the intended behaviour.</p>
<h4>Excessive Imports (ExcessiveImports)</h4>
<p class="desc">Category: REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">A high number of imports can indicate a high degree of coupling within an object. This rule counts the number of unique imports and reports a violation if the count is above the user-specified threshold. The default value is set to 30.</p>
<p class="desc">ExcessiveImports attempts to count all unique imports a class contains. This rule will count a <code>import com.something.*;</code> as a single import.</p>
<p class="desc">This rule impacts reusability, since many classes need to be available for this class to work.</p>
<h4>Simplify Boolean Expressions (SimplifyBooleanExpressions)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid unnecessary comparisons in boolean expressions, they serve no purpose and impacts readability.</p>
<p class="desc">This rule impacts analysability, since unnecessary code confuses the reader.</p>
<h4>Instantiation To Get Class (InstantiationToGetClass)</h4>
<p class="desc">Category: EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid instantiating an object just to call getClass() on it; use the .class public member instead.</p>
<p class="desc">This rule impacts resources, since the object will be unnecessarily created.</p>
<h4>Empty Finally Block (EmptyFinallyBlock)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Empty finally blocks serve no purpose and should be removed.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>Accessor Class Generation (AccessorClassGeneration)</h4>
<p class="desc">Category: </p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessor. A factory method, or non-privatization of the constructor can eliminate this situation. The generated class file is actually an interface. It gives the accessing class the ability to invoke a new hidden package scope constructor that takes the interface as a supplementary parameter. This turns a private constructor effectively into one with package scope, and is challenging to discern.</p>
<p class="desc">Javadoc's description of the execution: 1. Note all private constructors. 2. Note all instantiations from outside of the class by way of the private constructor. 3. Flag instantiations.</p>
<h4>Avoid Using Hard Coded IP (AvoidUsingHardCodedIP)</h4>
<p class="desc">Category: CHA REU POR</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Application with hard-coded IP addresses can become impossible to deploy in some cases. Externalizing IP adresses is preferable.</p>
<p class="desc">This pattern impacts changeability, since it is easier to change the IP in an externalised configuration file. It also impacts reusability, since the hard coded IP address may not be adapted to a different usage. It also impacts portability since the hard coded IP address may not be adapted to a different environment (network</p>
<h4>Extends Object (ExtendsObject)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 4</p>
<p class="desc">Description:</p>
<p class="desc">No need to explicitely extend Object, since all objects implicitely inherit from Object.</p>
<p class="desc">This pattern implies unnecessary code and impacts analysability.</p>
<h4>God Class (GodClass)</h4>
<p class="desc">Category: ANA CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">The God Class rule detects the God Class design flaw using metrics. God classes do too many things, are very big and overly complex. They should be split apart to be more object-oriented. The rule uses the detection strategy described in 'Object-Oriented Metrics in Practice'. The violations are reported against the entire class. See also the references: Michele Lanza and Radu Marinescu. Object-Oriented Metrics in Practice: Using Software Metrics to Characterize, Evaluate, and Improve the Design of Object-Oriented Systems. Springer, Berlin, 1 edition, October 2006. Page 80.</p>
<p class="desc">This rule impacts analysability, since an overly complex class is difficult to read. It also impact changeability, since separating the various fonctionalities of the class may be difficult.</p>
<h4>Override Both Equals And Hash code (OverrideBothEqualsAndHashcode)</h4>
<p class="desc">Category: CHA REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Override both public boolean Object.equals(Object other), and public int Object.hashCode(), or override neither. Even if you are inheriting a hashCode() from a parent class, consider implementing hashCode and explicitly delegating to your superclass. </p>
<p class="desc">Even if at some time only one of these methods is indeed used, a maintainer will assume that the code is consistent, i.e. the hashCode and equals functions are both overriden to fit the new behaviour.</p>
<h4>Non Static Initializer (NonStaticInitializer)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">A non-static initializer block will be called any time a constructor is invoked (just prior to invoking the constructor). While this is a valid language construct, it is rarely used and is confusing.</p>
<p class="desc">This rule impacts analysability, since a maintainer will look for the constructor as the first chunk of code executed.</p>
<h4>Unused Private Method (UnusedPrivateMethod)</h4>
<p class="desc">Category: ANA EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Unused Private Method detects when a private method is declared but is unused.</p>
<p class="desc">This rule impacts analysability, since the maintainer will not understand why this method is declared. It also impacts resources, since there is an unused declared method.</p>
<h4>Optimizable toArray Call (OptimizableToArrayCall)</h4>
<p class="desc">Category: EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Calls to a collection's toArray() method should specify target arrays sized to match the size of the collection. Initial arrays that are too small are discarded in favour of new ones that have to be created that are the proper size.</p>
<p class="desc">This rule impacts resources, since the array will have to be discarded and recreated at the right size when it is populated.</p>
<h4>Check ResultSet (CheckResultSet)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Always check the return values of navigation methods (next, previous, first, last) of a ResultSet. If the value return is 'false', it should be handled properly.</p>
<p class="desc">This pattern impacts the reliability, since the intended action may not have been performed correctly without the caller to know it.</p>
<h4>Broken NullCheck (BrokenNullCheck)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 2</p>
<p class="desc">Description:</p>
<p class="desc">The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.</p>
<p class="desc">This pattern impacts the reliability, since an exception may be thrown.</p>
<h4>Simplify Boolean Returns (SimplifyBooleanReturns)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid unnecessary if-then-else statements when returning a boolean. The result of the conditional test can be returned instead.</p>
<p class="desc">This rule impacts analysability, since unnecessary code confuses the reader.</p>
<h4>Constructor Calls Overridable Method (ConstructorCallsOverridableMethod)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Calling overridable methods during construction poses a risk of invoking methods on an incompletely constructed object and can be difficult to debug. It may leave the sub-class unable to construct its superclass or forced to replicate the construction process completely within itself, losing the ability to call super(). If the default constructor contains a call to an overridable method, the subclass may be completely uninstantiable. Note that this includes method calls throughout the control flow graph - i.e., if a constructor Foo() calls a private method bar() that calls a public method buz(), this denotes a problem.</p>
<p class="desc">Searches through all methods and constructors called from constructors. It marks as dangerous any call to overridable methods from non-private constructors. It marks as dangerous any calls to dangerous private constructors from non-private constructors.</p>
<p class="desc">This rule impacts reliability, since the object may not be fully initialised. It may throw exceptions or cause an unpredictable behaviour.</p>
<h4>Jumbled Incrementer (JumbledIncrementer)</h4>
<p class="desc">Category: CHA REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid jumbled loop incrementers - it is usually a mistake, and is confusing even if intentional.</p>
<p class="desc">It impacts changeability, since modifying the loop will probably have some side-effects. It also impacts reliability by increasing the complexity of code, thus inducing more opportunities for bugs.</p>
<h4>Singular Field (SingularField)</h4>
<p class="desc">Category: CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Fields whose scopes are limited to just single methods do not rely on the containing object to provide them to other methods. They may be better implemented as local variables within those methods.</p>
<p class="desc">This rule impacts changeability, since it is easier to modify a variable at the method level than at the class level.</p>
<h4>Abstract Class Without Abstract Method (AbstractClassWithoutAbstractMethod)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">The abstract class does not contain any abstract methods. An abstract class suggests an incomplete implementation, which is to be completed by subclasses implementing the abstract methods. If the class is intended to be used as a base class only (not to be instantiated directly) a protected constructor can be provided to prevent direct instantiation.</p>
<p class="desc">This rule impacts analysability, since the class is pointless regarding the abstract intent and the maintain will wonder why this class is abstract.</p>
<h4>Position Literals First In Case Insensitive Comparisons (PositionLiteralsFirstInCaseInsensitiveComparisons)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Position literals first in comparisons, if the second argument is null then NullPointerExceptions can be avoided, they will just return false.</p>
<p class="desc">This rule impacts reliability, since a NullPointerException will arise if the object is null.</p>
<h4>Return From Finally Block (ReturnFromFinallyBlock)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid returning from a finally block, this can discard exceptions.</p>
<p class="desc">It impacts reliability because the caught exception may hide another unseen exception.</p>
<h4>Dont Use Float Type For Loop Indices (DontUseFloatTypeForLoopIndices)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">Don't use floating point for loop indices: the termination test may misbehave due to floating point granularity. If you must use floating point, use double unless you're certain that float provides enough precision and you have a compelling performance need (space or time).</p>
<p class="desc">This rule impacts reliability, since the loop may terminate at an unexpected time.</p>
<h4>Unused Formal Parameter (UnusedFormalParameter)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid passing parameters to methods or constructors without actually referencing them in the method body.</p>
<p class="desc">This rule impacts analysability, since the maintainer will not understand why this parameter is declared.</p>
<h4>Avoid Multiple Unary Operators (AvoidMultipleUnaryOperators)</h4>
<p class="desc">Category: ANA REL</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">The use of multiple unary operators may be problematic, and/or confusing. Ensure that the intended usage is not a bug, or consider simplifying the expression.</p>
<p class="desc">This rule impacts the reliability, since the pattern has a good probability to be a bug. It also impacts analysability, since such unary operators are unnecessarily complex to understand.</p>
<h4>Position Literals First In Comparisons (PositionLiteralsFirstInComparisons)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Position literals first in comparisons, if the second argument is null then NullPointerExceptions can be avoided, they will just return false.</p>
<p class="desc">This rule impacts reliability, since a NullPointerException will arise if the object is null.</p>
<h4>Switch Density (SwitchDensity)</h4>
<p class="desc">Category: ANA CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">A high ratio of statements to labels in a switch statement implies that the switch statement is overloaded. Consider moving the statements into new methods or creating subclasses based on the switch variable. The threshold can be configured by the user, default value is 10.</p>
<p class="desc">Switch Density is the number of statements over the number of cases within a switch. The higher the value, the more work each case is doing. When the Switch Density is high, you should start looking at Subclasses or State Pattern to alleviate the problem.</p>
<p class="desc">This rule impacts analysability, since it builds a complex control structure. It also impacts changeability, since it implies a large number of complex paths, which may cause side-effects.</p>
<h4>Bad Comparison (BadComparison)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid equality comparisons with Double.NaN. Due to the implicit lack of representation precision when comparing floating point numbers these are likely to cause logic errors.</p>
<p class="desc">This rule impacts reliability, since the comparison may produce unpredictable behaviour because of the floating precision.</p>
<h4>Double Checked Locking (DoubleCheckedLocking)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">Partially created objects can be returned by the Double Checked Locking pattern when used in Java. An optimizing JRE may assign a reference to the baz variable before it creates the object the reference is intended to point to. For more details refer to: http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html</p>
<p class="desc">The double check pattern impacts reliability, since the code may produce a crash or unpredictable behaviour when the half-defined class is used.</p>
<h4>Collapsible If Statements (CollapsibleIfStatements)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Sometimes two consecutive 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.</p>
<p class="desc">Collapsible if statements add unnecessary code and complexity.</p>
<h4>Misplaced Null Check (MisplacedNullCheck)</h4>
<p class="desc">Category: REL ANA</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">The null check here is misplaced. If the variable is null a NullPointerException will be thrown. Either the check is useless (the variable will never be 'null') or it is incorrect.</p>
<p class="desc">This pattern impacts the reliability, since an exception may be thrown. It also impacts analysability, since the maintainer will take unnecessary time to understand that the null is misplaced.</p>
<h4>Missing Static Method In Non Instantiatable Class (MissingStaticMethodInNonInstantiatableClass)</h4>
<p class="desc">Category: EFF ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">A class that has private constructors and does not have any static methods or fields cannot be used.</p>
<p class="desc">This rule impacts analysability, since an unusable class represents unnecessary code. It also impact resources for the memory unnecessarily used.</p>
<h4>Confusing Ternary (ConfusingTernary)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid negation within an 'if' expression with an 'else' clause. For example, rephrase: if (x != y) diff(); else same(); as: if (x == y) same(); else diff(); Most 'if (x != y)' cases without an 'else' are often return cases, so consistent use of this rule makes the code easier to read. Also, this resolves trivial ordering problems, such as 'does the error case go first?' or 'does the common case go first?'.</p>
<p class="desc">This rule impacts analysability.</p>
<h4>Loose Package Coupling (LoosePackageCoupling)</h4>
<p class="desc">Category: REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid using classes from the configured package hierarchy outside of the package hierarchy, except when using one of the configured allowed classes.</p>
<p class="desc">The loose package coupling Rule can be used to ensure coupling outside of a package hierarchy is minimized to all but an allowed set of classes from within the package hierarchy. For example, supposed you have the following package hierarchy: org.sample, org.sample.impl, org.sample.util, and the allowed class org.sample.SampleInterface. This rule can be used to ensure that all classes within the org.sample package and its sub-packages are not used outside of the org.sample package hierarchy. Further, the only allowed usage outside of a class in the org.sample hierarchy would be via org.sample.SampleInterface.</p>
<p class="desc">TODO: doesn't work without configuring the allowed classes.</p>
<p class="desc">This rule impacts reusability, since many packages need to be available for this class to work.</p>
<h4>Switch Statements Should Have Default (SwitchStmtsShouldHaveDefault)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">All switch statements should include a default option to catch any unspecified values.</p>
<p class="desc">This rule impacts reliability, since an unpredictable behaviour may result if the switch value was not intended.</p>
<h4>Avoid Using Octal Values (AvoidUsingOctalValues)</h4>
<p class="desc">Category: REL ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Integer literals should not start with zero since this denotes that the rest of literal will be interpreted as an octal value.</p>
<p class="desc">This rule impacts reliability, since the number specified may not be the one intended. It also impacts analysability, since the maintainer will have trouble deciding if the value is a decimal or octal value.</p>
<h4>Immutable Field (ImmutableField)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Identifies private fields whose values never change once they are initialized either in the declaration of the field or by a constructor. This helps in converting existing classes to becoming immutable ones.</p>
<p class="desc">This rule impacts analysability, since it will help the maintainer understand the variable is not supposed to change.</p>
<h4>Avoid Instanceof() Checks In Catch Clause (AvoidInstanceofChecksInCatchClause)</h4>
<p class="desc">Category: CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Each caught exception type should be handled in its own catch clause.</p>
<p class="desc">This rule impacts changeability, since the type of exception and its treatment is straight-forward.</p>
<h4>Unused Modifier (UnusedModifier)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Fields in interfaces are automatically public static final, and methods are public abstract. Classes or interfaces nested in an interface are automatically public and static (all nested interfaces are automatically static). For historical reasons, modifiers which are implied by the context are accepted by the compiler, but are superfluous.</p>
<p class="desc">TODO: The rule's priority could be lowered.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>Unconditional If Statement (UnconditionalIfStatement)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid returning from a finally block, this can discard exceptions.</p>
<p class="desc">A maintainer will have trouble understanding why an unconditional if has been used. It further clutters the code.</p>
<h4>Unnecessary Local Before Return (UnnecessaryLocalBeforeReturn)</h4>
<p class="desc">Category: ANA EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid the creation of unnecessary local variables.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code. It also impacts resources, since an unnecessary variable is created.</p>
<h4>Unsynchronized Static Date Formatter (UnsynchronizedStaticDateFormatter)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">SimpleDateFormat instances are not synchronized. Sun recommends using separate format instances for each thread. If multiple threads must access a static formatter, the formatter must be synchronized either on method or block level.</p>
<p class="desc">Using a DateFormatter (SimpleDateFormatter) which is static can cause unexpected results when used in a multi-threaded environment. This rule will find static (Simple)DateFormatters which are used in an unsynchronized manner. Refer to these Bug Parade issues: 4093418 4228335 4261469 see RFE1020790 - Check for SimpleDateFormat as singleton http://sourceforge.net/tracker/index.php?func=detail&aid=1020790&group_id=56262&atid=479924</p>
<p class="desc">This rule impacts reliability, since an unexpected behaviour may arise from the thread's synchronisation.</p>
<h4>Empty Statement Not In Loop (EmptyStatementNotInLoop)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">An empty statement (or a semicolon by itself) that is not used as the sole body of a 'for' or 'while' loop is probably a bug. It could also be a double semicolon, which has no purpose and should be removed.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>Avoid Decimal Literals In BigDecimal Constructor (AvoidDecimalLiteralsInBigDecimalConstructor)</h4>
<p class="desc">Category: REL CHA</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">One might assume that the result of 'new BigDecimal(0.1)' is exactly equal to 0.1, but it is actually equal to .1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or as a binary fraction of any finite length). Thus, the long value that is being passed in to the constructor is not exactly equal to 0.1, appearances notwithstanding. The (String) constructor, on the other hand, is perfectly predictable: 'new BigDecimal('0.1')' is exactly equal to 0.1, as one would expect. Therefore, it is generally recommended that the (String) constructor be used in preference to this one.</p>
<p class="desc">This rule impacts product reliability, since the actual number is not the one intended and precision errors may arise.</p>
<h4>ClassCastException With toArray (ClassCastExceptionWithToArray)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">When deriving an array of a specific class from your Collection, one should provide an array of the same class as the parameter of the toArray() method. Doing otherwise would result in a ClassCastException.</p>
<p class="desc">This pattern impacts the reliability, since an exception may be thrown.</p>
<h4>Idempotent Operations (IdempotentOperations)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Avoid idempotent operations - they have no effect.</p>
<p class="desc">This rule impacts analysis, since it adds unnecessary code.</p>
<h4>Avoid Protected Field In Final Class (AvoidProtectedFieldInFinalClass)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc"> Do not use protected fields in final classes since they cannot be subclassed. Clarify your intent by using private or package access modifiers instead.</p>
<p class="desc">This rule impacts analysability, since the intent of the field modifier is not clear.</p>
<h4>Abstract Class Without Any Method (AbstractClassWithoutAnyMethod)</h4>
<p class="desc">Category: CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">If an abstract class does not provides any methods, it may be acting as a simple data container that is not meant to be instantiated. In this case, it is probably better to use a private or protected constructor in order to prevent instantiation than make the class misleadingly abstract.</p>
<p class="desc">This rule impacts changeability, since the intent of the class is made much clearer for the maintainer.</p>
<h4>Loose Coupling (LooseCoupling)</h4>
<p class="desc">Category: REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">The use of implementation types as object references limits your ability to use alternate implementations in the future as requirements change. Whenever available, referencing objects by their interface types provides much more flexibility.</p>
<p class="desc">This rule impacts reusability, since many classes need to be available for this class to work.</p>
<h4>Preserve Stack Trace (PreserveStackTrace)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Throwing a new exception from a catch block without passing the original exception into the new exception will cause the original stack trace to be lost making it difficult to debug effectively.</p>
<p class="desc">This rule impacts analysability, since the original exception trace is lost.</p>
<h4>Avoid Protected Method In Final Class Not Extending (AvoidProtectedMethodInFinalClassNotExtending)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Do not use protected methods in most final classes since they cannot be subclassed. This should only be allowed in final classes that extend other classes with protected methods (whose visibility cannot be reduced). Clarify your intent by using private or package access modifiers instead.</p>
<p class="desc">This rule impacts analysability, since the intent of the method modifier is not clear.</p>
<h4>Use Locale With Case Conversions (UseLocaleWithCaseConversions)</h4>
<p class="desc">Category: EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">When doing <code>String.toLowerCase()</code>/<code>toUpperCase()</code> conversions, use Locales to avoids problems with languages that have unusual conventions, i.e. Turkish.</p>
<p class="desc">This rule impacts reliability, since it may produce an unpredictable behaviour for different locales.</p>
<h4>Empty Switch Statements (EmptySwitchStatements)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: </p>
<p class="desc">Description:</p>
<p class="desc">Empty switch statements serve no purpose and should be removed.</p>
<p class="desc">This rule impacts analysability, since it implies unnecessary code.</p>
<h4>Use Notify All Instead Of Notify (UseNotifyAllInsteadOfNotify)</h4>
<p class="desc">Category: REL</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Thread.notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only one is chosen. The thread chosen is arbitrary; thus its usually safer to call notifyAll() instead.</p>
<p class="desc">This rule impacts reliability, since the notified thread is chosen arbitrary among the waiters and an unintended behaviour may arise.</p>
<h4>Avoid Synchronized At Method Level (AvoidSynchronizedAtMethodLevel)</h4>
<p class="desc">Category: EFF CHA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Method-level synchronization can cause problems when new code is added to the method. Block-level synchronization helps to ensure that only the code that needs synchronization gets it.</p>
<p class="desc">This rule impacts resources, since unnecessarily synchronised code will cluter threads queue. It also impacts changeability, since the maintainer will need to refactor the method to add unsynchronised code.</p>
<h4>Uncommented Empty Constructor (UncommentedEmptyConstructor)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Uncommented Empty Constructor finds instances where a constructor does not contain statements, but there is no comment. By explicitly commenting empty constructors it is easier to distinguish between intentional (commented) and unintentional empty constructors.</p>
<p class="desc">This rule impacts analysability, since the maintainer does not know if the empty constructor was really intended and useful.</p>
<h4>Empty Method In Abstract Class Should Be Abstract (EmptyMethodInAbstractClassShouldBeAbstract)</h4>
<p class="desc">Category: REU</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Empty methods in an abstract class should be tagged as abstract. This helps to remove their inapproprate usage by developers who should be implementing their own versions in the concrete subclasses.</p>
<p class="desc">This rule impacts reusability, since it helps inheriting the class correctly.</p>
<h4>Default Label Not Last In Switch Statement (DefaultLabelNotLastInSwitchStmt)</h4>
<p class="desc">Category: ANA</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">By convention, the default label should be the last label in a switch statement.</p>
<p class="desc">This rule impacts analysability, since the maintainer will have trouble seeing the default case.</p>
<h4>Empty If Stmt (EmptyIfStmt)</h4>
<p class="desc">Category: ANA EFF</p>
<p class="desc">Priority: 3</p>
<p class="desc">Description:</p>
<p class="desc">Empty If Statement finds instances where a condition is checked but nothing is done about it.</p>
<p class="desc">This rule impacts analysability, since it introduces unnecessary code. It also impacts resources, since it takes unnecessary space and cpu.</p>
</body></html>
